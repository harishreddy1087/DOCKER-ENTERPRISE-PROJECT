#Version: "3.9"
#3.9 is latest stable version compatible with modern Docker features like healthchecks, volumes, and networks
services:
  frontend:
  #build: ./frontend â†’ Dockerfile location to build the frontend image
    build: ./frontend
    ports: 
      - "8080:80"
      #depends_on â†’ Ensures the backend container is healthy before frontend starts
    depends_on:
      backend:
        condition: service_healthy
        #Interview point: â€œI use depends_on with service_healthy to control startup order and avoid 404 errors if backend isnâ€™t ready.â€

  backend:
  #build: ./backend â†’ Builds backend Docker image from backend/Dockerfile
    build: ./backend
    env_file: .env
    ports:
      - "5000:5000"
    volumes:
      - /logs:/app-h/logs
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:5000/health"]
      interval: 10s
      retries: 5
      #Interview point:â€œI use health checks for reliable container orchestration, and volumes to persist logs even if containers are recreated.â€

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: companydb
      #volumes: â†’ Mounts init.sql to container to auto-create table/data on startup
    volumes:
      - ./db:/docker-entrypoint-initdb.d
    healthcheck:
       test: ["CMD-SHELL", "pg_isready -U admin"]
       interval: 10s
       retries: 5
  volumes:
    log:    
#â€œI mount the SQL file to initialize DB automatically and use a healthcheck to make sure the DB is ready before backend connects.â€


# ğŸ’¡ Interview Tip

# If asked:

# â€œWhy not just run docker run for each container?â€

# You can say:

# â€œUsing docker-compose.yml I can spin up all 3 services with a single command, manage dependencies, healthchecks, logging, and environment configs â€” exactly like a production microservices setup.â€